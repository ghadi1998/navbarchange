{"version":3,"sources":["../../server/routes/users.js"],"names":["express","require","users","Router","cors","jwt","bcrypt","User","use","process","env","SECRET_KEY","post","req","res","today","Date","userData","username","body","first_name","last_name","email","password","created","findOne","where","then","user","hash","err","create","json","status","catch","send","error","compareSync","token","sign","dataValues","expiresIn","get","decoded","verify","headers","id","module","exports"],"mappings":"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","file":"users.js","sourcesContent":["//express requirement\r\nconst express = require('express')\r\n//setting a users variable to be used as a router instead of app post , get ..\r\nconst users = express.Router()\r\n//cross oigin resource sharing \r\nconst cors = require('cors')\r\n//jwt for user login authentication\r\nconst jwt = require('jsonwebtoken')\r\n//bcrypt for password encryption and decryption\r\nconst bcrypt = require('bcrypt')\r\n//using te user model\r\nconst User = require('../model/user')\r\n//setting users as cros origin functionalities\r\nusers.use(cors())\r\n//privat key or jwt encryption and decryption\r\nprocess.env.SECRET_KEY = 'q1w2e3r4t5y6u7i8o9p0o9i8u7y6t5r4e3w2q1'\r\n\r\n//main signup function , exported\r\nusers.post('/signup', (req, res) => {\r\n  //setting a new user object to be manipulated and inserted to db \r\n  //data taken from react client side \r\n  const today = new Date()\r\n  const userData = {\r\n    username : req.body.username,\r\n    first_name: req.body.first_name,\r\n    last_name: req.body.last_name,\r\n    email: req.body.email,\r\n    password: req.body.password,\r\n    created: today\r\n  }\r\n\r\n  //a function from sequelize , a wrapper for later on functions\r\n  //searches if the username is found or not \r\n  User.findOne({\r\n    where: {\r\n      //searching in the whhole db for this user name \r\n     username: req.body.username\r\n    }\r\n  })\r\n    // encrypting the password using bcrypt encryption function\r\n    //bcrypt uses a hash function to encrypt the user given password\r\n    //will not reach this part if user is duplicated\r\n    .then(user => {\r\n      if (!user) {\r\n        //hashing the password , 10 is a number for permutations 2pwr10 = a certain string built in\r\n        bcrypt.hash(req.body.password, 10, (err, hash) => {\r\n          userData.password = hash\r\n          //creating a user with the given data\r\n          User.create(userData)\r\n          //send the username to the response tab in console\r\n            .then(user => {\r\n              res.json({ status: user.username + '    '+ 'Registered!' })\r\n            })\r\n            //any error will be consoled here\r\n            .catch(err => {\r\n              res.send('error: ' + err)\r\n            })\r\n        })\r\n      } else {\r\n        //will reach if username is found ,  User.findOne \r\n        res.json({ error: 'User already exists' })\r\n      }\r\n    })\r\n    .catch(err => {\r\n      res.send('error: ' + err)\r\n    })\r\n})\r\n\r\n//main login functionality\r\nusers.post('/login', (req, res) => {\r\n  ///searches for username in db at first\r\n  User.findOne({\r\n    where: {\r\n     username: req.body.username\r\n    }\r\n  })\r\n  //if the user is found , it compared the password with the given password\r\n  //it compared it the encrypted pass in the db\r\n  //and decrypts it to compare\r\n    .then(user => {\r\n      if (user) {\r\n        //if user name is found the deryption starts here\r\n        if (bcrypt.compareSync(req.body.password, user.password)) {\r\n          //each user is given a certain jwt token for authentication\r\n          //jwt.sign , Synchronously sign the given payload into a JSON Web Token string payload\r\n          //secret key provided above\r\n          //token is assigned using the front end whuck sends it with the request\r\n          let token = jwt.sign(user.dataValues, process.env.SECRET_KEY, {\r\n            expiresIn: 1440\r\n          })\r\n          //send token to local storage of the browser that checks it \r\n          res.send(token)\r\n        }\r\n      } else {\r\n        //reaches here if user isnt found\r\n        res.status(400).json({ error: 'User does not exist' })\r\n      }\r\n    })\r\n    //catches any error from the above blocks\r\n    .catch(err => {\r\n      res.status(400).json({ error: err })\r\n    })\r\n})\r\n\r\nusers.get('/profile', (req, res) => {\r\n  //Synchronously verify given token using a secret or a public key to get a decoded token token -\r\n  // JWT string to verify secretOrPublicKey - Either the secret for HMAC algorithms, \r\n  //or the PEM encoded public key for RSA and ECDSA.\r\n  // [options] - Options for the verification returns - The decoded token.\r\n  var decoded = jwt.verify(req.headers['authorization'], process.env.SECRET_KEY)\r\n\r\n\r\n  //searches for user\r\n  User.findOne({\r\n    //decode user id and jwt \r\n    where: {\r\n      id: decoded.id\r\n    }\r\n  })\r\n  //if true, user is sent as a json object to browser\r\n    .then(user => {\r\n      if (user) {\r\n        res.json(user)\r\n      } else {\r\n        //if false , send this response\r\n        res.send('User does not exist')\r\n      }\r\n    })\r\n    .catch(err => {\r\n      res.send('error: ' + err)\r\n    })\r\n})\r\n\r\nmodule.exports = users"]}